# 问题

**问题4.1**：如果可以通过在*S*中的任意位置插入语言中的0个或多个令牌来生成*U*，那么字符串*U*称为字符串*S*的一个*超级序列（supersequence）*。（见12.4节）

- a) 为语法*G*设计一个Unger解析器，且*G*生成的语言中的一个字符串可以被识别为*G*的一个*超级序列*。

- b) 设计一个CYK解析器，要求同上。

**问题4.2**：如果可以通过删除*S*中任意位置的零个或多个token来生成*U*，那么字符串*U*称为字符串*S*的一个*子序列（subsequence）*。（见12.4节）

- a) 为语法*G*设计一个Unger解析器，该解析器可以识别*G*生成的语言中的字符串的*子序列*。

- b) 设计一个CYK解析器，要求同上。

**问题4.3**：从语法中去掉ε规则将会很大程度的改变语法，在解析过程中必须要花大力气来恢复这种破坏。通过将删除的ε规则合并到修改后的语法中可以省掉一些麻烦，如下所示。给定一个语法**S--->aBc, B--->b|ε**，我们先将其转换为“AND-OR”形式，将原本的右侧记为非终结符。（只有AND规则和OR规则两种的语法即属于AND-OR形式，AND规则即语法符号是并列关系，OR规则即非终结符是择其一关系，并且对于每一个非终结符而言，同时只有一个规则存在。）上面的语法就成为了**S--->aBc, B--->B<sub>b</sub> |B<sub>ε</sub> , B<sub>b</sub> --->b, B<sub>ε</sub> --->ε**。接下来替换所有为空的OR规则（举例中**B**的规则）：**S--->$$S_{aB_{b}c}$$|$$S_{aB_{\xi }c}$$, $$S_{aB_{b}c}$$--->aB<sub>b</sub>c, $$S_{aB_{\xi }c}$$--->aB<sub>ε</sub>c, B<sub>b</sub>--->b, B<sub>ε</sub>--->ε**。接下里替换*A → ε*形式的规则：**S--->$$S_{aB_{b}c}$$|$$S_{aB_{\xi }c}$$, $$S_{aB_{b}c}$$--->aB<sub>b</sub>c, $$S_{aB_{\xi }c}$$--->ac, B<sub>b</sub>--->b**。在我们解析**$$S_{aB_{\xi }c}$$--->ac**时，*S*的角标就是真正的右侧。用解析器将这个想法细化为一个完整的算法。

**问题4.4**：从下面的语法中删除单元规则：

**<center>S<sub>S</sub> ---> T</center>**

**<center>T ---> U</center>**

**<center>U ---> T</center>**

**问题4.5**：拓展题：CYK，尤其是图标解析形式，长久以来一直是自然语言解析的最爱方式，即便我们已经知道时间成本是*O(|G||P<sub>av</sub>|n<sup>3</sup>)*。当遇到一些非常大的自然语言语法时（拥有数百万规则），更甚至是它所生成的语言，那么仅仅*O(|G|)*就已经很成问题了，勿论*O(|P<sub>av</sub>|)*。请设计一个CYK/图表形式的优化版本（比*O(|G|)*更优）。不要指望|ADJ|比*|G|<sup>2</sup>*更小，ADJ是任意右侧会出现的非终结符对的集合。（见问题3.11）

**问题4.6**：在编辑器中查看源代码时，成对出现的命令（tokens）可以让语法结构一目了然。这就去掉了CYK坚持的很多自底向上的假设。这个方法可以自动去掉大部分的表输入，只留下很少的一部分。这使得它几乎成为一个时间要求为线性的解析器，而这对于解析旧代码可能很重要，因为旧代码通常语法非常难搞。

先检查*A*生成的非终结符之前、开头、中间、结尾、之后的命令，然后在尝试减少*A → α*形式的假设。

**问题4.7**：将4.3节中计算*T<sub>i,A</sub>*的推理规则格式化。

**问题4.8**：使用识别段的结束位置作为第二个索引绘制图Fig4.8和Fig4.16。

**问题4.9**：Rus算法适用的*确定性*的语法类型有哪些。

**问题4.10**：形式语言：设计一个算法，将给定语法转换为一个非终结符数量尽可能少的语法。这一点很重要，因为很多解析算法的时间成本取决于语法的大小。