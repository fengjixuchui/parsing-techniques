# 4.3.2 自底向上表解析

自底向上表解析可以正确填充所有输入内容，但要比自顶向下算法更仔细一些。就像CYK一样，对于CNF类型的语法它的效率最高，因此我们将尽可能保证我们的语法属于这类。而且与CYK一样，在计算时关于输入内容的顺序我们要小心处理。此外，我们将填充图Fig4.21的三维“楔形（背面）”（其输入为布尔（位(Bits)）），而不是正面的二维部分（其输入内容是整数列表）。楔形的输入内容描述了一个终结符的生成是否是来自于位置*i*长度*K*的*A*（写作*T<sub>i,A,K</sub>*）。

自底向上表解析对整个识别表的填充过程开始于右端的起始列。为了填充输入*T<sub>i,A,K</sub>*，我们从语法中找到了一个*A → BC*形式的规则，然后我们就可以访问到*T<sub>i,B,1</sub>*。如果这个输入已经设置好了吗，那么在位置*i*就有*B*生成的一个长度位*1*的段。如果都设置好了，那我们接下来就访问*T<sub>i+1,C,k−1</sub>*，同理在位置*i+1*有*C*生成的长度位*k-1*的一个段。由此我们得出结论，在位置*i*的长度为*K*的输入段会有一个*A*的终结符生成，我们将此输入称为*T<sub>i,A,K</sub>*。如果不对，依次检查*T<sub>i,B,2</sub>*和*T<sub>i+2,C,K-2</sub>*等等，直到*T<sub>i,B,K-1</sub>*和*T<sub>i+k-1,C,1</sub>*，就像CYK算法一样。

我们可以在*T<sub>i+K-1,C,1</sub>*停止，因为CNF语法中没有ε规则，因此*T<sub>i+k,C,0</sub>*并不存在。这意味着*T<sub>i,A,K</sub>*在计算过程中会涉及到*T<sub>i,B,j</sub>*（仅只当*j < K*时）。因此当我们在*T<sub>i,Q,K</sub>*(*j < K*，*P*和*Q*为任意值)之前计算*T<sub>i,P,j</sub>*，那么就需要确保计算*T<sub>i,A,K</sub>*输入内容和值都已经准备好了。就会对算法施加特定的计算顺序：

![图1](../../img/4.3.2_1.png)

计算*T<sub>i,A,K</sub>*的成本是*O(n|P<sub>av</sub>|)*，其中*n*是输入的长度而*|P<sub>av</sub>|*是一个非终结符产生规则数的平均值。正如我们看到的，这个计算重复了*O(n|G|n)*次，其中*|G|*与语法的大小成正比。因此这个解析算法的时间成本为*O(n<sup>3</sup>|G||P<sub>av</sub>|)*或*O(n<sup>3</sup>)×O(|G||P<sub>av</sub>|)*。

自底向上表解析应用于12章和15.7节的许多算法中。

Nederhof 和 Satta [40]写了一个关于表解析的教程，并将其广泛应用于非确定性解析算法中。